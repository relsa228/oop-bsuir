# Clean architecture
**Цель:** изучить архитектурный подход Clean architecture в применении к серверной стороне web-приложения.
## Теоретические данные
В предыдущих главах (лабах) были рассмотрены базовые принципы и паттерны проектирования отдельных системных модулей, они важны, но они не дают представления о том, как должно быть устроено приложение в целом. Для разных типов приложений существуют разные полноценные архитектурные паттерны. Для десктопных (на самом делел для любых, где есть представления и внутренняя логика соединены в одном приложении) приложений это [MVC](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller), [MVP](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter), [Elm](https://guide.elm-lang.org/architecture/), [Flux](https://www.freecodecamp.org/news/an-introduction-to-the-flux-architectural-pattern-674ea74775c9/) и прочие; [MVVM](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel) для мобильной разработки; [FSD](https://feature-sliced.design/docs/get-started/overview) для разработки клиентских веб-приложений -- этот список можно продолжать очень долго. В рамках текущей работы предлагаем рассмотреть паттерн для написания серверной части веб-приложений, который известен как *Clean Architecture*.
### Генеалогия Clean Architecture
Автором этого подхода является (небезызвестный) Роберт Мартинс. При формулировании своей архитектуры он опирался на ранее существовавшие решения, а именно:
- [Гексагональная архитектура](https://en.wikipedia.org/wiki/Hexagonal_architecture_(software));
- [DCI](https://en.wikipedia.org/wiki/Data,_context_and_interaction);
- [BCE](https://en.wikipedia.org/wiki/Entity%E2%80%93control%E2%80%93boundary).
Он выделил основную проблему, которую решают эти подходы -- *изоляция задач*; и способ, которым они это делают -- *разделение на уровни*. Кроме этого было сформулировано еще пять основных характеристик, которым отвечала каждая из рассмотренных архитектур:
- *независимость от фреймворков*: подходы универсальны, они не нацелены на конкретную технологию;
- *простота тестирования*: логические модули изолированы, есть возможно тестировать их отдельно друг от друга (использую [DI](https://github.com/relsa228/oop-bsuir/blob/main/6.%20Dependency%20Injection%20%26%20testing.md#dependency-injection) добавляются моковые зависимости);
- *независимость от пользовательского интерфейса*: пользовательский интерфейс может быть изменен без затрагивания остальной системы;
- *независимость от базы данных*: нет привязки к конкретной технологии хранения данных;
- *независимость от любых внешних интеграций*: внутренняя логика полностью изолирована от любых внешних интерфейсов.
### Clean Architecture как таковая
В попытке объединить все подходы была составлена следующая диаграмма:
![[CleanArchitecture.jpg]]

Круги на схеме представляют разные уровни программного обеспечения: *чем ближе к центру, тем выше уровень*. Далее было сформулировано *правило зависимостей*:

>Зависимости в исходном коде должны быть направлены внутрь, в сторону высокоуровневых политик.

Если разобрать это правило на составные части, то получим следующие правила:
- ничто во внутреннем круге ничего не знает о внешних кругах;
- ничто, объявленое во внешнем круге, не должно использоваться во внутреннем;
- ничто во внешнем круге не должно влиять на внутренние круги.
#### Entities
Данный слой содержит в себе, как несложно догадаться, сущности, а именно некоторые высокоуровневые бизнес-правила, которые специфичны для предметной области. Предполагается, что сущности мало подвержены изменениям, тем более почти невероятна ситуация, когда этот слой меняется полностью. Сущности могут быть представлены как объектами с методами, так и структурами с функциями; главное, чтобы они инкапсулировали в себе основную бизнес-логику.
#### Use cases
Слой вариантов использования содержит бизнес-правила, которые специфичны для конкретного приложения. Он содержит логику с более низким уровнем абстракции, чем сущности и может быть изменен, однако эти изменения не должны затрагивать сущности.
#### Controllers
Этот слой связывает бизнес-логику системы с внешними интеграциями. Как правило здесь находятся различные адаптеры данных, которые преобразуют информацию от вариантов использования и сущностей к формату, необходимому для внешних интеграций.
#### External Interfaces
Слой интерграции внешних систем. Здесь работают базы данных, фреймворки, веб-интерфейс и прочее, что по сути не требует (или почти не требует) участия разработчика для функционирования.
### Гибкость
Отдельно отметим, что Clean Architecture -- это гибкая парадигма, количество слоев никогда не фиксировано и может менять от проекта к проекту. Ключевой момент здесь это соблюдение *правила зависимостей*. Его имплементация практически гарантирует, что архитектура будет рабочей.
## References
1. Martin, Robert C. _Clean Architecture: A Craftsman’s Guide to Software Structure and Design_. Prentice Hall, 2018.
## Задание
Реализовать backend для одной из следующих систем:
 1. **Система управления коворкингом:**
	- *Управление зонами:* Просмотр доступных рабочих мест, переговорных комнат и офисов.
	- *Бронирование:* Возможность забронировать место на конкретную дату и время. Валидация пересечений (одно место не может быть занято дважды).
	- *Тарифы:* Расчет стоимости аренды в зависимости от длительности (часовая, дневная, месячная).
	- *Администрирование:* Добавление новых локаций и просмотр текущей загрузки.

 2.  **Платформа для обмена книгами**
	- *Каталог:* Добавление книг (название, автор, ISBN) и их поиск по фильтрам.
	- *Владение:* Пользователь может добавить книгу в свой "личный фонд".
	- *Обмен:* Запрос на получение книги у другого пользователя. Фиксация истории перемещения книги.
	- *Рейтинг:* Возможность оставить отзыв и оценку книге или надежности пользователя.

3. **Трекер личных финансов**
	- *Счета:* Создание нескольких счетов (наличные, карта).
	- *Транзакции:* Фиксация доходов и расходов с категориями (еда, транспорт, досуг).
	- *Лимиты:* Установка ежемесячных бюджетов на категории (предупреждение при превышении).
	- *Аналитика:* Получение сводки расходов за период в разрезе категорий.

4. **Платформа для проведения технических интервью**
	- *Справочник вопросов:* База задач по категориям сложности и темам.
	- *Интервью:* Создание сессии интервью, куда прикрепляются конкретный интервьюер и кандидат.
	- *Фидбек:* Заполнение чек-листа по итогам собеседования (soft skills, hard skills) с итоговой рекомендацией (Hire/No Hire).
	- *Расписание:* Возможность интервьюера выставить свои слоты доступности.

5. **Cистема управления доставкой еды**
	- *Меню:* Просмотр списка ресторанов и их блюд с актуальными ценами.
	- *Корзина:* Формирование заказа, расчет итоговой стоимости с учетом доставки.
	- *Статусы:* Изменение состояния заказа (Принят -> Готовится -> В пути -> Доставлен).
	- *Курьеры:* Назначение свободного курьера на заказ (автоматически или вручную админом).

Backend должен реализовывать простые функции работы с пользователем (авторизация, аутентификация, регистрация). Кроме этого необходимо имплементировать базовый функционал согласно выбранной предметной области.
Необходимо покрыть функции тестами. В качестве интерфейса пользователя использовать **swagger**.
Приложение должно быть выполнено в стиле *Clean Architecture*, предлагается следующая структура (от внешних к внутренним):
- `api` - слой отвечает за реализацию хендлеров (обработка входящих запросов);
- `controllers` - содержит в себе основную бизнес-логику приложения;
- `clients` - слой для работы с интеграциями (базы данных, другие микросервисы, внешние провайдеры данных и т.д.);
- `models` - слой для структур данных (возможно `DTO`);
- `shared` - содержит общие служебные сущности, которые напрямую не относятся к логике (схемы ответов, классы ошибок и прочее).

Помните, что архитектор может менять количество слоев и их назначение в зависимости от специфики проекта. Главное соблюдать основные принципы *Clean Architecture* (в частности речь идет про изоляцию слоев).
## Definition of done
- Разработано приложение.
- Написаны тесты.
- Обосновано применены паттерны проектирования.
- Создана необходимая проектная документация.
