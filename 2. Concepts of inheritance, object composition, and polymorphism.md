# Concepts of inheritance, object composition, and polymorphism
**Цель:** освоить способы имплементации более сложных связей между объектами с помощью базовых принципов ООП.
## Теоретические данные
### Наследование
Важной фитчей всего ООП подхода является наличие широких возможностей для продвинутого переиспользования кода. Это достигается через семантику выстраивания отношений между классами.

**Наследование** позволяет классу перенимать поля и методы другого класса. Важно отметить, что обычно речь идет про реализацию в себе *интерфейса* класса-родителя (публичных методов и полей), однако положение дел на практике будет зависеть от конкретного языка программирования и доступных там модификаторах доступа.

В контексте наследования часто используются понятия *родительского* и *дочернего* класса (superclass и subclass). Родительским классом называют класс, который предоставляет минимальный интерфейс для реализации, дочерний класс реализует в себе интерфейс родительского и может расширять этот интерфейс, добавляя свои методы и поля, или переопределять поведение (не меняя сигнатуры методов).

Наследование открывает путь к выстраиванию сложных семантических иерархий, каждая ветвь которой может уточнять предыдущий понижая уровень абстракции. В качестве примера можно взять иерархию видов транспорта.

![Classes](https://github.com/relsa228/oop-bsuir/blob/main/materials/images/classes.png)


На приведенной схеме можно четко заметить имплементацию **is-a** отношения между классами. Is-a отношение подразумевает, что некоторый A класс является описанием некоторой абстракции, к которой можно отнести класс B. То есть:
- *Наземный транспорт* is a *транспорт*; (1)
- *Лошадь* is a *наземный транспорт*. (2)
<br>Отметим, что связь is-a является транзитивной, то есть если утверждения (1) и (2) истинны, то утверждение "*Лошадь* is a *транспорт*" тоже будет истинным.
### Объектная композиция 
Другим подходом к построению объектов является *объектная композиция*. Если для наследования используется отношение is-a, то для объектной композиции применяют **has-a**. Has-a отношение описывает связь между классами, когда класс A является частью класса B. 

В данном случае (в отличии от is-a) классы как правило находятся на одном уровне абстракции, то есть это буквально составные части друг-друга, они могут вовсе не иметь какого-то общего абстрактного понятия (либо иметь, но на настолько высоком уровне абстракции, что этой связью можно пренебречь). 

Для примера можно взять персональный компьютер. Внутри него есть материнская плата, оперативная память, процессор, видеокарта и другие компоненты. То есть, можно сказать, что:
- *Персональный компьютер* has a *процессор*; (3)
- *Персональный компьютер* has a *оперативная память*; (4)
- *Персональный компьютер* has a *материнская плата*. (5)
<br>Это три независимых утверждения, которые ничего не говорят друг о друге -- мы не можем сказать, что утверждение (4) верно (или неверно), если верны (или неверны) утверждения (3) и (5). Однако, если мы проведем дополнительную декомпозицию например материнской платы и введем утверждение:
- *Материнская плата* has a *северный мост*
<br>то можно будет сказать, что:
- *Персональный компьютер* has a *северный мост*.
### Полиморфизм
Если инкапсуляция описывает то, как должен быть построен объект; наследование то, какие могут быть отношения между объектами; то полиморфизм говорит о том, как объекты работают с контекстом. Иными словами, полиморфизм позволяет не создавать новые классы (как это делает наследование), а добавляет гибкости уже существующим. Существует три основных вида полиморфизма:
- **Ad hoc (специальный)** полиморфизм;
- **параметрический** полиморфизм;
- полиморфизм **подтипов**.
<br>Рассмотрим кратко каждый из них.
#### Ad hoc полиморфизм
Общий смысл ad hoc подхода в полиморфизме -- неявное изменение логики в зависимости от входных данных. Это может быть реализовано через:
- **Перегрузку методов**, когда создается нескольких методов с одним именем, но разными сигнатурами (типами или количеством параметров) в рамках одного класса.
- **Приведение типов**, когда происходит неявное преобразование типов, когда одна операция применяется к разным типам (например, `1 + 1.5`, где целое преобразуется в число с плавающей точкой: `1` -> `1.0`).
#### Параметрический полиморфизм
Данны подход нацелен на устранение зависимости от конкретного типа данных. Здесь вместо типов данных как таковых используются дженерики (шаблонные типы), которые могут рамочно описывать поведение предполагаемого входного типа (а могут и не описывать, тогда предполагается, что метод работает со всеми возможными типами). Ярким примером такого подхода являются классы-контейнеры, которые есть в стандартной библиотеке почти любого языка. Как правило они объявляются следующим образом `List<T>`, где вместо `T` при использовании указывается конкретный тип.
#### Полиморфизм подтипов
Параметрический полиморфизм является статическим (типы данных, которые будут подставлены вместо шаблона будут известны компилятору на этапе собственно компиляции), если нам нужен динамический вариант, то это полиморфизм подтипов. Полиморфизм подтипов предполагает, что в сигнатуре метода используются базовые (родительские) типы, а при использовании туда могут подставляться подтипы (дочерние). Далее возможны два сценария:
- **Переопределение методов:** Подкласс предоставляет свою реализацию метода, уже определенного в родительском классе.
- **Позднее связывание:** Решение о том, какой именно метод (базовый или переопределенный) вызвать, принимается во время выполнения программы (в рантайме), исходя из реального типа объекта, а не типа ссылки.
## Задание
Необходимо расширить и уточнить абстрактное описание предметной области из предыдущей работы. Используйте для этого подходы объектной композици и наследование, это поможет описать более сложные взаимосвязи между сущностями внутри описываемой системы.
## Definition of done
- Обновлена UML-схема.
- Расширено описание предметной области из прошлой работы.
- Организованы сложные связи между сущностями через механизмы наследования и объектной композиции.
- Использованы разные виды полиморфизма
