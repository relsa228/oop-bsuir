# GRASP and GoF design patterns. Creational patterns
**Цель:** познакомиться с методологиями современного системного дизайна. Изучить и применить на практике порождающие паттерны.
## Теоретические данные
В предыдущей главе (лабе) уже была упомянута важность формализации подходов и практик в проектировании ПО. Кроме этого были рассмотрены самые простые из них. Однако по мере того как усложнялось ПО стало очевидно, что существует потребность в каталогизации более сложных и прикладных решений. Так в середине 90-х появились две основные парадигмы:
- **GoF (Gang of Four):** В 1994 году [Эрих Гамма](https://en.wikipedia.org/wiki/Erich_Gamma), [Ричард Хелм](https://en.wikipedia.org/wiki/Richard_Helm), [Ральф Джонсон](https://en.wikipedia.org/wiki/Ralph_Johnson_(computer_scientist)) и [Джон Влиссидес](https://en.wikipedia.org/wiki/John_Vlissides) (собственно, Банда *четырех*) издали книгу *Design Patterns*, где описали 23 классических паттерна проектирования. Они сфокусированы на гибкости и повторном использовании структур.
- **GRASP (General Responsibility Assignment Software Patterns):** [Крейг Ларман](https://en.wikipedia.org/wiki/Craig_Larman) в книге *Applying UML and Patterns* предложил 9 принципов. В отличие от GoF, GRASP — это не всегда готовые модульные архитектурные решения, обычно это общие правила разграничения зон ответственности между сущностями.
### GRASP принципы
Начнем с рассмотрения GRASP принципов так как они более обобщенные и фундаментальные. Поговорим о них в том порядке, в каком они были упомянуты в книге (первые *пять* там названы *основными*, остальные же носят более вспомогательный характер).
#### Information expert
> Назначить обязанность *информационному эксперту* -- классу, у которого имеется информация, требуемая для выполнения задания.

Это наиболее общий принцип распределения ответственности. Он предполагает, что выполнять задачу должна та сущность из модели проектирования, которая уже *имеет всю необходимую для этого информацию*. Если такой сущности в модели проектирования нет, то стоит обратиться к модели предметной области и уточнить модель проектирования, создав дополнительные классы.
#### Creator
> Назначить классу `B` обязанность создавать экземпляры класса `A`, если выполняется одно из следующих условий.
> - Класс `B` *агрегирует* объекты `A`.
> - Класс `B` *содержит* объекты `A`.
> - Класс `B` *записывает* экземпляры объектов `A`.
> - Класс `B` *активно использует* `A`.
> - Класс `B` *обладает данными инициализации*, которые будут передаваться объектам `A` при их создании.
> Класс `B` -- *создатель* объектов `A`.
> Если выполняется несколько из этих условий, то лучше использовать класс `B`, агрегирующий или содержащий класс `A`.

Данный шаблон описывает принцип, по которому следует определять, какой класс должен отвечать за создание объектов другого класса. Если его сократить, то создавать должен тот, кто *использует*, или тот, кто *обладает полнотой информации* необходимой для создания. Таким образом достигается смысловая однородность модулей системы и четко разграничиваются разные области модели проектирования.
#### Low Coupling
> Распределить обязанности таким образом, чтобы степень связанности оставалась низкой.

Этот принцип рекомендует проектировать систему так, чтобы избегать сильной связности между классами. Степень связности определяется через два параметра:
- *функциональная* зависимость от других элементов;
- обладание *информацией* о других элементах.
Низкая связность достигается с помощью четкого разделения зон ответственности на этапе проектирования. Классы с высокой связностью должны быть декомпозированы, а модель проектирования уточнена.
#### High Cohesion
> Распределение обязанностей, поддерживающее высокую степень зацепления.

*Зацеплением* (cohesion) называют меру связанности и сфокусированности обязанностей класса. То есть, объект обладает высокой степенью зацепления, если его обязанности тесно связаны между собой и ограничены количественно. То есть речь снова про [single responsobility]().
#### Controller
>Делегирование обязанностей по обработке системных сообщений классу, удовлетворяющему одному из следующих условий.
>- Класс представляет всю систему в целом, устройство или подсистему (внешний контроллер).
>- Класс представляет сценарий некоторого прецедента, в рамках которого выполняется обработка всех системных событий. Тогда:
>	- для всех системных событий в рамках одного сценария прецедента используется один и тот же класс-контроллер.
>	- неформально, сеанс -- это экземпляр взаимодействия с исполнителем. Сеансы могут иметь произвольную длину, но зачастую организованы в рамках прецедента.

Данный принцип описывает подход работы с *системными событиями*, то есть с событиями высокого уровня, генерируемыми внешним исполнителем и связаны с *системными операциями*, которые выполняются системой в ответ на события. Методы выполнения системных операций определяются в *контроллерах*. При этом сами контроллеры никогда не взаимодействуют с пользователем напрямую, между ними всегда есть *классы-интерфейсы*, которые описывают окна, виды, аплеты и т.д. (если речь про оконное приложение) или хенделеры некоторых роутов (для серверных приложений). Задачей класса-интерфейса является принять ввод пользователя, преобразовать его в системное событие и передать в контроллер.
#### Polymorphism
>Если поведение объектов одного типа (класса) может изменяться, обязанности распределяются для различных вариантов поведения с использованием полиморфных операций для этого класса.

Собственно, название говорит само за себя. Данный принцип предписывает избегать условной передачи управления, вместо этого рекомендуется использовать классические подходы полиморфизма.
#### Pure Fabrication
> Присвоить группу обязанностей с высокой степень зацепления искусственному классу, не представляющему конкретного понятия из предметной области, то есть синтезировать искусственную сущность для поддержки высокого зацепления, слабого связывания и повторного использования.
> Такой класс является продуктом воображения разработчика и представляет собой *синтетику* (fabrication). В идеальной ситуации, присвоенные этому классу обязанности поддерживают высокую степень зацепления и низкое связывание, так что структура этого синтетического класса является очень прозрачной или *чистой* (Pure Fabrication == Чистая синтетика). 

Здесь описывается механизм ввода в модель проектирования классов, которые четко не относятся к предметной области, а выполняют некоторую *служебную роль*. Обычно это что-то вроде самописных контейнеров, кэшей, абстракций для запросов данных от внешних интеграции и всего в этом роде.
#### Indirection
>Присвоить обязанности промежуточному объекту для обеспечения связи между другими компонентами или службами, которые не связаны между собой напрямую. При таком подходе связи *перенаправляются* между другими компонентами или службами.

Этот шаблон раскрывает подход к решению проблемы связывания разных модулей системы, не теряя потенциал переиспользования и не повышая уровень прямой связности объектов. Предлагаемым решением являются *классы-адаптеры*. Они служат внешними интерфейсами для модулей и преобразуют ответ одного модуля во входные данные для другого. Кроме этого можно использовать [служебные классы](#Pure Fabrication), благодаря своей абстрактности они хорошо подойдут в качестве, например, межмодульного буффера.
#### Protect variations
> Идентифицировать точки возможных вариаций или неустойчивости; разделить обязанности таким образом, чтобы обеспечить устойчивый интерфейс.

Этот принцип затрагивает проблему устойчивости интеграции, он предполагает создание настолько абстрактных интерфейсов подсистем, чтобы изменение внутренней реализации (логики) не затрагивало внешние интеграции. Сюда же могут подойти и [адаптеры](#Indirection), и техники [полиморфизма](#Polymorphism), главная цель -- обеспечение [независимости абстракции от реализации]()
### GoF паттерны
Как уже было отмечено, GoF паттерны -- это прикладные, модульные архитектурные решения. Они формализованы и каталогизированы в довольно абстрактном виде, что позволяет их легко имплементировать в различных системах без привязки к предметной области.
GoF паттерны делятся на три типа:
- **Порождающие:** описывают способы создания (гибкой инициализации) объектов.
- **Структурные:** описывают способы сборки (композиции) объектов в крупные структуры.
- **Поведенческие:** описывают поведение объектов, распределение ответственности и способов взаимодействия.
Далее будет рассмотрено по три паттерна из каждой категории, остальные желательно изучить самостоятельно.
### Порождающие GoF паттерны
Порождающие паттерны призваны абстрагировать процесс инстанцианизации объектов. Они призваны сделать систему независимой от того как объекты создаются, объединяются и презентуются. Перечень порождающих паттернов:
- *абстрактная фабрика*;
- *строитель (builder)*;
- *фабричный метод*;
- *прототип*;
- *одиночка (singleton)*.
#### Абстрактная фабрика
> Предоставление интерфейса для создания семейств связанных объектов без определения конкретного класса.

Абстрактная фабрика предполагает, во-первых, *выделение абстрактных интерфейсов для каждого типа порождаемых элементов*. После этого создается также *абстрактный интерфейс для создания объектов*, он работает также без привязки к конкретной реализации. В методах такого интерфейса возвращаются не конкретные типы, а интерфейсы, которые были выделены на первом шаге. Собственно, полученный интерфейс и будет абстрактной фабрикой.
#### Строитель
>Отделить создание сложного объекта от его представления, чтобы один и тот же процесс создания мог отдавать разные конечные представления.

Сутью данного паттерна является *разбиение процесса создания объекта на несколько этапов* вместо создания одного универсального конструктора. То есть инциализация объекта происходит не через один метод (конструктор), а через выполнение набора последовательных методов. Такой подход часто используют в ORM при создании запроса (типо `let query = select(...).from(...).where(...)`).
#### Прототип
> Определить тип объекта через сущность-прототип и создавать новые объекты через копирование его прототипа.

Данный паттерн применяется в случаях, когда для создания нового объекта необходимо скопировать старый. Проблемой является то, что некоторые поля (если обращаться к определению инкапсуляции, то вообще все поля) могут быть недоступны извне. Паттрен прототип предлагает *делегировать обязанности по созданию корректного объекта-копии самому объекту-прототипу* через имплементации интерфейса клонирования (он может содержать всего один метод, например, `clone()`) 
## References
1. Design Patterns
2. Applying UML and Patterns
## Задание
Реализовать простую логистическую систему. Система должна рассчитывать стоимость и скорость доставки некоторой партии грузов некоторым способом до некоторой точки. 
Оператор передает системе информацию о партии груза, расстоянию до точки назначения и способ доставки (по воде, по земле или по воздуху). Номенклатура доступных товаров, их характеристики, а также характеристики траспортных средств приведены в [файле](file).
Расчет стоимости доставки происходит по формуле:
</br>
$P = \sum c_{i} \cdot m_{i} + r \cdot p_{delivery}$
</br>
где
</br>
	$c_{i}$ -- стоимость перевозки одного килограмма груза вида $i$;
	</br>
	$m_{i}$ -- общая масса груза вида $i$ в партии;
	</br>
	$r$ -- расстояние до точки;
	</br>
	$p_{delivery}$ -- накладные расходы вида транспорта на одну единицу расстояния.
	</br>
Необходимо следить, что система соответствует принципам GRASP (в частности *Information Expert* и *Creator*). Для работы с разными видами транспорта и товаров рекомендуется использовать порождающие паттерны (например *Abstract factory*).
## Definition of done
- Система реализована согласно заданию.
- Система протестирована на функциональную полноту и логическую корректность.
- Базово соблюдены принципы системного дизайна (GRASP). 
- Порождающие паттерны проектирования корректно имплементированы.
