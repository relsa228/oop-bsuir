# Refactoring && Code quality
**Цель:** изучить базовые практики написания качественного и поддерживаемого кода в ООП стиле.
## Теоретические данные
Проектирование программного обеспечения в целом ничем принципиально не отличается от проектирования самолетов или электростанций -- все это проявления инженерного искусства. И как и везде в проектировании программного обеспечения есть некоторые подходы, которые за годы практики тысяч разработчиков зарекомендовали себя как эффективные.

Начиная с самых простых и универсальных подходов рассмотрим базовые акронимы: **KISS**, **YAGNI** и **DRY** -- эти принципы довольно очевидны и исходят из простого здравого смысла, однако всегда удобно, когда даже настолько базовые вещи описаны и формализованы.
#### KISS
Один из самых старых акронимов, он появился в 1960-х года и был отмечен в частности флотом США. Авторство обычно приписывают старшему инженеру компании Lockheed Martin, работавшему в подразделения перспективных разработок, [Кларенсу Джонсону](https://en.wikipedia.org/wiki/Kelly_Johnson_(engineer)).

*KISS* расшифровывается как *Keep It Simple, Stupid* (на самом деле вариантов расшифровки гораздо больше, но семантически они все одинаковые). Данный принцип утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются. 

В применении к самолетам Lockheed Martin это означает, что дизайн должен быть таким, чтобы с ремонтом мог справиться обычный механик в полевых условиях. Если речь идет про ПО, то уровень простоты системы должен быть на максимально возможном рациональном уровне. То есть, KISS не запрещает использовать сложные паттерны или нестандартные подходы, KISS лишь говорит, что необходимость таких решений должна быть обоснована и если есть более простые решения, то при прочих равных предпочтение стоит отдать им. 
#### YAGNI
Этот принцип генеалогически восходит к довольно старой методологии [экстремального программирования](https://en.wikipedia.org/wiki/Extreme_programming). Сформулирован он был в работах одного из главных методологов XP [Рона Джеффриса](https://en.wikipedia.org/wiki/Ron_Jeffries).

Акроним расшифровывается как *You Ain't Gonna Need It*. В корне своей философии XP (как и любой [agile](https://en.wikipedia.org/wiki/Agile_software_development)-подобный подход) имеет стремлении писать максимально гибкие и адаптивные под меняющиеся требования клиентов системы. И это очень четко ощущается в YAGNI. Данный принцип говорит, что не стоит реализовывать какой-то функционал заранее. 

Допустим программисту поступила задача сделать выгрузку системных отчетов в `xlsx` формате, он подумал и кроме `xlsx` сделал еще выгрузку в `json` и `xml`. Никто об этих функциях не просил, никому они не нужны прямо сейчас и не факт, что понадобятся в будущем, но время и ресурсы на их реализацию уже потрачены. Один такой случай сам по себе не является серьезной проблемой, серьезной проблемой является накопление такой невостребованной логики. Она делает систему более громоздкой, сложной (вернемся к [KISS](#KISS)) и лишает даже намека на гибкость.
#### DRY
Говоря про *Don't repeat yourself* на ум сразу приходит переиспользование кода и этот принцип действительно об этом, но не только об этом. В своей книге Программист-прагматик [Энди Хант](https://en.wikipedia.org/wiki/Andy_Hunt_(author)) и [Дейв Томас](https://en.wikipedia.org/wiki/Dave_Thomas_(programmer)) выводят понятие переиспользования на более высокий уровень, оно касается любого *знания* внутри системы. То есть в идеальной ситуации должен переиспользоваться не только код, но и документация, конфигурации, тесты и прочее. Если вместо написания трех абзацев можно дать ссылку -- надо дать ссылку.
#### SOLID
Если все предыдущие акронимы были максимально абстрактными (и поэтому универсальными) общеинженерными подходами, то SOLID уже конкретно относится к области проектирования ПО и неприменим к другим доменам инженерного дела (без дополнительного абстрагирования). SOLID был собран [Робертом Мартином](https://en.wikipedia.org/wiki/Robert_C._Martin) из пяти отдельных принципов (по одному на каждую букву). Разберем отдельно каждый из них:
##### The Single Responsibility Principle (SRP)
> У класса должна быть только одна причина для изменения

У класса должна быть своя определенная зона ответственности. То есть не должно быть ситуаций, когда один класс может, например, одновременно писать в базу и отправлять электронные письма. Необходимо декомпозировать такой функционал и создать несколько разных классов.
##### The Open Closed Principle (OCP)
> Класс должен быть открыт для расширения, но закрыт для модификации

Мартин назвал этот принцип наиболее важным в объектно-ориентированном дизайне. Этот принцип говорит, что нам следует проектировать классы так, чтобы они могли быть расширены без изменения. Иными словами, мы должны иметь возможность изменить поведение без изменения исходного кода класс.
##### The  [Liskov](https://en.wikipedia.org/wiki/Barbara_Liskov) Substitution Principle (LSP)
>Должна быть возможность подменить родительский класс дочерним

Данный принцип относится к механизму наследования (в широком смысле). Он говорит о том, что дочерние классы всегда должны выполнять контракт своего родительского класса, то есть реализовывать весь его публичный интерфейс (чтобы в любом месте в коде можно было бы заменить родительский класс дочерним и не получить ошибку).
##### The Interface Segregation Principle (ISP)
> Множество специализированных интерфейсов лучше чем один общий

Данный принцип, несколько схож с [SRP](#The Single Responsibility Principle (SRP)), он тоже предполагает разделение зоны ответственности между интерфейсами. Он говорит, что не стоит заставлять клиентов зависеть от методов, которые он не использует. То есть интерфейс `Weapon`, который реализует в себе методы `sharpen()`, `reload()` и `fill()` стоит разделить на три интерфейса `Blade`, `Firearm` и `WarMachinery`. Отличием от SRP здесь будет то, что мы все равно можем создать класс с размытой зоной ответственности, просто тогда он будет реализовывать в себе все три интерфейса сразу, что как минимум поможет скрыть лишние функции при построении зависимости от этого класса, если понадобится.
##### The Dependency Inversion Principle (DIP)
> Зависимости должны восходить к абстракциям, а не к реализациям

Инверсия зависимостей это стратегия, которая предполагает зависимость от интерфейсов и абстрактных функций (любых типов абстракций) вместо зависимости от конкретных реализаций. Говоря на примере, если вы реализуете какой-то класс-репозиторий и вам нужно создать зависимость между этим классом и клиентом базы данных, то имеет смысл создать отдельный интерфейс, где вы опишите все необходимые репозиторию методы, после чего выстроить зависимость между репозиторием и этим интерфейсом. Так вы сможете использовать не один конкретный клиент, а любой, который реализует в себе контракт абстрактного интерфейса.
## Refernces
1. Elegant Objects, Yegor Bugayenko
2. Proggrammer-progmatic
3. Design Principles and Design Patterns
## Задание
Есть образец [кода](https://github.com/relsa228/oop-bsuir/tree/main/materials/orders), необходимо провести его рефакторинг в соответсвии с принципами SOLID. 

После этого необходимо реализовать следующий функционал (также соблюдая SOLID):
1. Добавить поддержку *дисконтных карт*:
	- **Функционал:** Есть три вида карт: `Gold` (скидка 15%), `Silver` (скидка 10%) и `Newbie` (скидка 0%). Учитывать скидку при расчете цены. 
2. Добавить уведомление в *Telegram* и *внутреннюю систему логирования*.
	- **Функционал:** Теперь при успешной обработке заказа письмо должно уходить не только клиенту на Email, но и менеджеру в Telegram, а также записываться в текстовый лог событий.
3. Реализовать кэширование заказов.
	- **Функционал:** Если мы пытаемся сохранить один и тот же заказ дважды, система не должна обращаться к «тяжелой» БД (файлу), а должна выдать сообщение: «Заказ уже есть в кэше».
## Definition of done
- Код приведен в порядок, повышено общее качество и читаемость.
- Закончена реализация требуемого функционала.
