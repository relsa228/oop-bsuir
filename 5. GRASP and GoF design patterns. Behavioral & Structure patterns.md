# GRASP and GoF design patterns. Behavioral & Structure
**Цель:** познакомиться с методологиями современного системного дизайна. Изучить и применить на практике поведенческие и структурные паттерны проектирования.
## Теоретические данные
Продолжим изучение GoF паттернов. Рассмотрим оставшиеся два вида: *поведенческие* и *структурные*.
### Поведенческие GoF паттерны
Поведенческие паттерны созданы для упрощения коммуникации между объектами системы и повышения эффективности распределения обязанностей. Существует десять поведенческих паттернов:
- *цепочка обязанностей*;
- *команда*;
- *итератор*;
- *посредник*;
- *снимок*;
- *наблюдатель*;
- *состояние*;
- *стратегия*;
- *шаблонный метод*;
- *посетитель*.
#### Итератор
>Предоставляет способ доступа к элементу агрегированного объекта последовательно без раскрытия его внутреннего представления.

Паттерн создан для абстрагирования процесса обхода элементов некоторого агрегированого объекта (например какой-то коллекции). Идея состоит в том, чтобы *вынести логику обхода из объекта коллекции вовне*. Таким образом создается объект-итератор, который хранит в себе состояние конкретного обхода. Это позволяет не просто обезопасить процесс обхода сам по себе, но и легко имплементировать новые алгоритмы обхода без изменения кода коллекции.
#### Наблюдатель
>Определяет связь один-ко-многим между объектами, таким образом когда один объект меняет свое состояние все его зависимости уведомляются об этом.

Здесь речь идет о *создании подписочного механизма на состояние для объектов*. Задачей объекта-наблюдателя является вести список с ссылками на подписчиков и отслеживать состояние целевого объекта. Как правило, наблюдатель сам предоставляет интерфейс с помощью которого объекты могут подписаться/отписаться на уведомления. В свою очередь объекты-подписчики обязаны реализовать в себе интерфейс для получения уведомлений, с этим интерфейсом будет работать наблюдатель.
#### Стратегия
> Определяем семейство алгоритмов, инкапсулируем каждый из них и делаем их взаимозаменяемыми. Стратегия позволяет алгоритму существовать независимо от конкретной реализации клиента.

Идея паттерна в *абстрагировании алгоритмов*. Каждый алгоритм (из семейства) обернут в свой собственный класс, таким образом изначальный класс, который без паттерна вызывал бы этот алгоритм, будет играть роль контекста в котором будет работать класс алгоритма. У всех классов-алгоритмов из одного семейства должен быть общий интерфейс, чтобы их легко можно было менять между собой.
### Структурные GoF паттерны
Последний тип паттернов нацелен на создание удобных и гибких иерархий классов. Это особенно важно, если речь идет о крупных системах с большим количеством модулей внутри. Есть восемь структурных паттернов:
- *адаптер*;
- *мост*;
- *компоновщик*;
- *декоратор*;
- *фасад*;
- *легковес*;
- *заместитель*.
#### Адаптер
> Конвертировать интерфейс класса в другой интерфейс, который ожидается клиентом. Адаптеры позволяют классам работать вместе несмотря на несовместимые интерфейсы.

Описание паттерна говорит само за себя, адаптер -- это *класс-конвертер*, он берет данные от объекта с интерфейсом A и преобразует их таким образом, чтобы они могли быть восприняты интерфейсом B. Работать это может не только с данными, но и с вызовами методов другого класса. Это выглядит следующим образом: класс A имеет совместим с интерфейсом адаптера, он вызывает некоторый метод адаптера, адаптер получает вызов класса A и перенаправляет его на определенный метод класса B.
#### Декоратор
>Динамически добавляет дополнительную ответственность объекту. Декораторы предоставляют гибкую альтернативу дочерним классам для расширения функциональности.

Декораторы по сути являются легковесной и динамической альтернативой наследованию. Расширение функциональности здесь происходит через [объектную композицию](https://github.com/relsa228/oop-bsuir/blob/main/2.%20Concepts%20of%20inheritance%2C%20object%20composition%2C%20and%20polymorphism.md#%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%B0%D1%8F-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D1%8F): создается *класс-обертка*, куда помещается объект изначального класса, после этого все взаимодействие с ним происходит через интерфейс обертки, где может быть прописана дополнительная логика.
#### Фасад
> Предоставляет унифицированный интерфейс для набора интерфейсов в подсистеме. Фасад определяет интерфейс высокого уровня который делает подсистему более легкой в использовании.

Опять же описание паттерна довольно исчерпывающее. Фасады нужны чтобы *скрыть огромное количество внешних интерфейсов подсистемы* и оставить только то, что будет нужно клиенту. 
## Задание
Доработать систему, созданную в предыдущей лабораторной работе. Необходимо спроектировать и реализовать модуль работы с внешними данными. Модуль должен выполнять следующие функции:
- принимать файлы с входными данными о товарах и способах транспортировки в разных форматах (`JSON`, `XML`, `CSV`);
- если пользователь после формирования перечня грузов в партии и задания финальной точки не определил тип транспорта, то необходимо отдавать в качестве результата список со всеми возможными вариантами (для каждого вида транспорта);
- должна быть возможность экспортировать ответ системы в файл;
  
*Структурные паттерны*: 
- необходимо реализовать следующие варианты сохранения файла:
	- сохранение в разных типах (`JSON`, `CSV`);
	- сохранение с шифрованием данных;
	- сохранение с сжатием (создается `.zip` архив с файлом);
- должна быть возможность комбинировать варианты сохранения между собой;
  
*Поведенческие паттерны*: 
- добавить возможность фильтрации по некоторым полям;
- пользователь может задать сортировку по полям ответа (*название транспорта*, *цена*, *скорость*) перед сохранением;
- сортировки можно комбинировать между собой.
## Definition of done
- Система дополнена согласно заданию.
- Система протестирована на функциональную полноту и логическую корректность.
- Паттерны проектирования корректно имплементированы.