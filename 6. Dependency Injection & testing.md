# Dependency Injection & testing
**Цель:** изучить практику Dependency Injection и научиться применять ее в создании модульных тестов.
## Теоретические данные
### Dependency Injection
Уже много было сказано про важность слабой связности и абстрагирования зависимостей. Важность этого была описана и у [Роберта Матина](), и у [Крейга Лармана](). Однако встает вопрос, как это проще всего реализовать на практике. *Dependency Injection* была наиболее полно описана в работе [Мартина Фаулера](https://en.wikipedia.org/wiki/Martin_Fowler_(software_engineer)) Inversion of Control Containers and the Dependency Injection pattern, там он ввел различие между паттерном *Inversion of Control* и новым паттерном *Dependency Injection*. Базово дана такая формулировка:

> Основная идея Dependency Injection состоит в том, чтобы иметь отдельный объект, сборщик, который заполняет поле некоторого класса с соответствующей реализацией для целевого интерфейса.

То есть, DI это строго говоря прикладное применение [DIP](https://github.com/relsa228/oop-bsuir/blob/main/3.%20Refactoring%20%26%26%20Code%20quality.md#the-dependency-inversion-principle-dip). Всего описано три разновидности DI:
- **Constructor Injection:** Зависимости передаются через конструктор при создании объекта. Это гарантирует валидность состоянии объекта после инициализации.
- **Setter Injection:** Позволяет менять зависимость в процессе работы объекта с помощью геттеров и сеттеров.
- **Interface Injection:** Объект реализует интерфейс, который описывает абстракцию (контракт) для внедрения зависимости.
### Unit-тестирование
По мере развития процессов создания программного обеспечения стала очевидна необходимость формализировать подходы к тестированию кода. Важной вехой здесь стало создание методологии модульных тестов. **Модульный тест** — это автоматизированный тест, который проверяет минимально возможную изолированную часть кода (обычно один метод одного класса).

Как уже было отмечено создание модульного теста -- часть общего процесса создания программного обеспечения, соответсвенно, здесь тоже существуют свои паттерны и принципы. В книге Clean Code Роберт Мартин описал пять характеристик, которыми должен обладать чистый тест, эти характеристика образуют собой акроним *FIRST*.
#### Fast
Тесты должны быть *быстрыми*. Суть этого правила в том, что тесты надо *запускать часто* (иначе в них нет смысла). Если они отрабатывают медленно, то каждый их запуск будет тратить много времени полезного времени разработчика, что с одной стороны является непродуктивным, а с другой стороны раздражающим. 
#### Independent
Тесты не просто так называются *модульными*. Важно понимать, что модульность здесь состоит из двух компонентов:
- независимость от *внешних интеграций*;
- независимость от *других тестов*.
Должна быть возможность выполнить все тесты в любом порядке, при этом не должно быть ситуации, когда один тест вызывает каскад сбоев. 
#### Repeatable
Тесты должны быть *воспроизводимыми в любой среде*. Тесты должны давать один и тот же результат на разных устройствах/разных контурах разработки. 
#### Self-Validating
Результат теста должен быть *однозначным*. То есть тест должен либо пройти, либо не пройти. Разработчик не должен проводить какие-то дополнительные исследования, чтобы узнать работает код или нет (никакого сравнения лог-файлов, проверки вывода консоли и прочего).
#### Timely
Писать тесты следует своевременно. Эта характеристика больше не про форму тестов, а про процесс их написания. Здесь рекомендуется *писать тесты непосредственно перед написанием самого кода*, иначе можно легко решить, что тестирование отнимает много времени, которое можно потратить на написание новой фитчи. Данный подход перекликается с методологией *TDD*.

Как видно, большинство правил написания хороших тестов завязано на обособлении тестов от общего контекста работы системы. Развитие концепции DI открыло здесь новые возможности. В целом, модульное тестирование -- это наиболее показательный пример важности DI в разработке. Именно грамотное внедрение DI позволяет подменять зависимости классов на моковые варианты, что делает архитектуру тестов чистой и переиспользуемой.
### TDD
TDD это крайне известная методология тестирования, ключевым аспектом которой является максима о том, что [тесты должны писаться до кода продукта](#Timely). Однако TDD не исчерпывается только этим правилом, Мартин сформулировал еще три закона TDD:
- *первый*: не пишите код продукта, пока не напишите отказной модульный тест;
- *второй*: не пишите модульный тест в объеме большем, чем необходимо для отказа (невозможность компиляции является отказом);
- *третий*: не пишите код продукта в объеме большем, чем необходимо для прохождения текущего отказного теста.
<br>Этот подход позволяет писать тесты своевременно, вместе с разработкой фитчи. В результате вы получите надежную систему полностью покрытую модульными тестами. При этом само написание тестов превращается из отдельной задачи в естественную часть процесса разработки.
## References
1. *Inversion of Control Containers and the Dependency Injection pattern*: https://martinfowler.com/articles/injection.html
2. Martin, Robert C. _Clean Code: A Handbook of Agile Software Craftsmanship_. Prentice Hall, 2016.
## Задание
Дана [система](https://github.com/relsa228/oop-bsuir/tree/main/materials/forecast) с внешними зависимостями. Необходимо написать тесты для функций работы с внешними провайдерами данных. Учесть пограничные случаи.
Необходимо доработать систему добавив следующий функционал:
- интегрировать нового провайдера данных (сейчас есть только OpenWeather, добавить [Google Weather API](https://developers.google.com/maps/documentation/weather/current-conditions)), предусмотреть возможность выбора провайдера при запросе;
- добавить получение прогноза погоды для локации;
- реализовать получение текущей температуры для нескольких локаций;
- добавить возможность вводить не только точные координаты места, но и просто название городов. Интегрировать необходимо следующие города:
	- Минск;
	- Лондон;
	- Токио;
	- Шанхай;
	- Варшава.
<br>Имплементацию новой логики следует согласно TDD подходу (в качестве доказательства будет приниматься история коммитов). Все роуты должны быть описаны в *swagger*.
## Definition of done
- Функционал, работающий с провайдерами данных, покрыт тестами.
- Система дополнена согласно требованиям.
- Новая логика также покрыта тестами и правильно встроена в систему.
